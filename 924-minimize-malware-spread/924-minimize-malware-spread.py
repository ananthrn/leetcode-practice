from collections import OrderedDict
class Solution:
    def bfs(self, src, graph: List[List[int]], initialSet: Set[int], seen: Set[int], adj) -> List[int]:
        n = len(graph)
        Q = deque()
        # seen = set()
        
        Q.appendleft(src)
        seen.add(src)
        
        # assert src not in initialSet
        
        setMal = set()
        
        if src in initialSet:
            setMal.add(src)
            
        compNum = 1
        
        while len(Q)>0:
            tp = Q.pop()
            
            for j in adj[tp]:
                if j in initialSet:
                    setMal.add(j)
                if j not in seen:
                    compNum += 1
                    seen.add(j)
                    Q.appendleft(j)
                    
        
        
        return list(setMal), compNum
    
    def bfsFast(self, src, initialSet: Set[int], seen: Set[int], adj) -> List[int]:
        Q = deque()
        # seen = set()
        
        Q.appendleft(src)
        seen.add(src)
        
        # assert src not in initialSet
        
        setMal = set()
        
        if src in initialSet:
            setMal.add(src)
            
        compNum = 1
        malNum = 1 if src in initialSet else 0
        
        while len(Q)>0:
            tp = Q.pop()
            
            for j in adj[tp]:
                if j not in seen:
                    if j in initialSet:
                        malNum +=1
                    compNum += 1
                    seen.add(j)
                    Q.appendleft(j)
                    
        
        
        return malNum, compNum
        
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        seen = set()
        initialSet = set(initial)
        
        malNum = OrderedDict([(node, 0) for node in sorted(initial)])
        n = len(graph)
        
        adj = defaultdict(list)
        
        for i in range(n):
            for j in range(n):
                if i!= j and graph[i][j] == 1:
                    adj[i].append(j)
                    adj[j].append(i)
                    
        # for src in range(n):
        #     if src not in seen:
        #         listMal, compNum = self.bfs(src, graph, initialSet, seen, adj)
        #         if len(listMal) == 1:
        #             malNum[listMal[0]] += compNum
        
        for src in initial:
            if src not in seen:
                malNumber, compNum = self.bfsFast(src, initialSet, seen, adj)
                if malNumber == 1:
                    malNum[src] += compNum
        
        print("malnNum: ", malNum)
        bestNode = max(malNum, key=malNum.get)
        
        return bestNode
        